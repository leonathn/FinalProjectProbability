<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indirect Temperature Estimation Using Kalman Filter</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600;700&family=Lato:wght@400;700&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Lato', 'Helvetica Neue', sans-serif;
            background: #ffffff;
            color: #2c3e50;
            line-height: 1.65;
            max-width: 1000px;
            margin: 0 auto;
            padding: 50px 30px;
        }

        header {
            text-align: center;
            padding-bottom: 30px;
            border-bottom: 3px solid #1a365d;
            margin-bottom: 40px;
        }

        h1 {
            font-family: 'Crimson Text', Georgia, serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: #1a365d;
            margin-bottom: 15px;
            line-height: 1.2;
        }

        .authors {
            font-size: 1.1rem;
            color: #34495e;
            margin: 10px 0;
        }

        .course-info {
            font-size: 0.95rem;
            color: #7f8c8d;
            margin: 5px 0;
            font-style: italic;
        }

        .links {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .links a {
            padding: 8px 18px;
            background: #1a365d;
            color: #fff;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .links a:hover {
            background: #27496d;
        }

        section {
            margin: 35px 0;
        }

        h2 {
            font-family: 'Crimson Text', Georgia, serif;
            font-size: 1.8rem;
            color: #1a365d;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
        }

        h3 {
            font-family: 'Crimson Text', Georgia, serif;
            font-size: 1.4rem;
            color: #34495e;
            margin: 25px 0 12px 0;
        }

        p {
            margin: 12px 0;
            text-align: justify;
        }

        ul {
            margin: 12px 0 12px 30px;
        }

        li {
            margin: 8px 0;
        }

        .figure {
            margin: 30px 0;
            text-align: center;
        }

        .figure img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .figure-caption {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #7f8c8d;
            font-style: italic;
        }

        .equation {
            background: #f8f9fa;
            padding: 15px;
            margin: 20px 0;
            border-left: 4px solid #1a365d;
            font-family: 'Source Code Pro', monospace;
            overflow-x: auto;
        }

        .parameters {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .parameters strong {
            color: #1a365d;
        }

        .statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #1a365d;
            border-radius: 4px;
        }

        .stat-box h4 {
            color: #1a365d;
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-box .value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .reference {
            font-size: 0.9rem;
            padding-left: 20px;
            text-indent: -20px;
            margin: 8px 0;
        }

        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .simulator-container {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 30px;
            margin: 30px 0;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .simulator-controls h3 {
            font-family: 'Crimson Text', Georgia, serif;
            font-size: 1.4rem;
            color: #1a365d;
            margin-bottom: 20px;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        .param-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
            font-family: 'Source Code Pro', monospace;
        }

        .sim-button {
            width: 100%;
            padding: 12px 20px;
            margin-top: 10px;
            background: #1a365d;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .sim-button:hover {
            background: #2c5282;
        }

        .sim-button.secondary {
            background: #718096;
        }

        .sim-button.secondary:hover {
            background: #4a5568;
        }

        .simulator-output {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #simCanvas {
            width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .sim-stats {
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-size: 0.95rem;
        }

        .sim-stats h4 {
            margin-bottom: 10px;
            color: #1a365d;
        }

        @media (max-width: 768px) {
            body {
                padding: 30px 20px;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .statistics {
                grid-template-columns: 1fr;
            }

            .simulator-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script>
        function runSimulation() {
            const trueBulb = parseFloat(document.getElementById('trueBulbTemp').value);
            const dA = parseFloat(document.getElementById('distA').value);
            const dB = parseFloat(document.getElementById('distB').value);
            const RA = parseFloat(document.getElementById('noiseA').value);
            const RB = parseFloat(document.getElementById('noiseB').value);
            const Q = parseFloat(document.getElementById('processNoise').value);
            const steps = parseInt(document.getElementById('numSteps').value);

            // Compute observation coefficients
            const HA = dB / (dA + dB);
            const HB = dA / (dA + dB);

            // Initialize arrays
            const sensorA = [];
            const sensorB = [];
            const kfEstimate = [];

            // Kalman Filter initialization
            let x_hat = trueBulb;
            let P = 10.0;

            // Generate synthetic data and run KF
            for (let i = 0; i < steps; i++) {
                // Simulate sensor readings with noise
                const zA = HA * trueBulb + (Math.random() - 0.5) * 2 * Math.sqrt(RA);
                const zB = HB * trueBulb + (Math.random() - 0.5) * 2 * Math.sqrt(RB);

                sensorA.push(zA);
                sensorB.push(zB);

                // Kalman Filter Prediction
                const x_pred = x_hat;
                const P_pred = P + Q;

                // Update with Sensor A
                const KA = P_pred * HA / (HA * HA * P_pred + RA);
                const x_A = x_pred + KA * (zA - HA * x_pred);
                const P_A = (1 - KA * HA) * P_pred;

                // Update with Sensor B
                const KB = P_A * HB / (HB * HB * P_A + RB);
                x_hat = x_A + KB * (zB - HB * x_A);
                P = (1 - KB * HB) * P_A;

                kfEstimate.push(x_hat);
            }

            // Calculate statistics
            const avgA = sensorA.reduce((a, b) => a + b, 0) / sensorA.length;
            const avgB = sensorB.reduce((a, b) => a + b, 0) / sensorB.length;
            const avgKF = kfEstimate.reduce((a, b) => a + b, 0) / kfEstimate.length;

            const stdA = Math.sqrt(sensorA.reduce((sum, val) => sum + (val - avgA) ** 2, 0) / sensorA.length);
            const stdB = Math.sqrt(sensorB.reduce((sum, val) => sum + (val - avgB) ** 2, 0) / sensorB.length);
            const stdKF = Math.sqrt(kfEstimate.reduce((sum, val) => sum + (val - avgKF) ** 2, 0) / kfEstimate.length);

            // Draw results
            drawChart(sensorA, sensorB, kfEstimate, trueBulb);

            // Display statistics
            document.getElementById('simStats').innerHTML = `
                <h4>Simulation Results:</h4>
                <p><strong>True Bulb Temperature:</strong> ${trueBulb.toFixed(1)}¬∞C</p>
                <p><strong>Sensor A:</strong> Mean = ${avgA.toFixed(1)}¬∞C, Std = ${stdA.toFixed(1)}¬∞C</p>
                <p><strong>Sensor B:</strong> Mean = ${avgB.toFixed(1)}¬∞C, Std = ${stdB.toFixed(1)}¬∞C</p>
                <p><strong>KF Estimate:</strong> Mean = ${avgKF.toFixed(1)}¬∞C, Std = ${stdKF.toFixed(1)}¬∞C</p>
                <p><strong>KF Error:</strong> ${Math.abs(avgKF - trueBulb).toFixed(1)}¬∞C</p>
            `;
        }

        function drawChart(dataA, dataB, dataKF, trueBulb) {
            const canvas = document.getElementById('simCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const allData = [...dataA, ...dataB, ...dataKF, trueBulb];
            const minY = Math.min(...allData) * 0.95;
            const maxY = Math.max(...allData) * 1.05;
            const steps = dataA.length;

            // Draw axes
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (i / 5) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();

                const value = maxY - (i / 5) * (maxY - minY);
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '12px Lato';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(0), padding - 10, y + 4);
            }

            // Helper function to convert data to canvas coordinates
            function toY(val) {
                return height - padding - ((val - minY) / (maxY - minY)) * graphHeight;
            }

            function toX(i) {
                return padding + (i / (steps - 1)) * graphWidth;
            }

            // Draw true bulb line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, toY(trueBulb));
            ctx.lineTo(width - padding, toY(trueBulb));
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw Sensor A
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            ctx.beginPath();
            dataA.forEach((val, i) => {
                if (i === 0) ctx.moveTo(toX(i), toY(val));
                else ctx.lineTo(toX(i), toY(val));
            });
            ctx.stroke();

            // Draw Sensor B
            ctx.strokeStyle = '#004e89';
            ctx.lineWidth = 2;
            ctx.beginPath();
            dataB.forEach((val, i) => {
                if (i === 0) ctx.moveTo(toX(i), toY(val));
                else ctx.lineTo(toX(i), toY(val));
            });
            ctx.stroke();

            // Draw KF Estimate
            ctx.strokeStyle = '#06a77d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            dataKF.forEach((val, i) => {
                if (i === 0) ctx.moveTo(toX(i), toY(val));
                else ctx.lineTo(toX(i), toY(val));
            });
            ctx.stroke();

            // Legend
            const legendX = width - padding - 120;
            const legendY = padding + 20;

            ctx.fillStyle = '#000000';
            ctx.font = 'bold 12px Lato';
            ctx.textAlign = 'left';
            ctx.fillText('True Bulb', legendX + 25, legendY);

            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + 15);
            ctx.lineTo(legendX + 20, legendY + 15);
            ctx.stroke();
            ctx.fillText('Sensor A', legendX + 25, legendY + 20);

            ctx.strokeStyle = '#004e89';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + 35);
            ctx.lineTo(legendX + 20, legendY + 35);
            ctx.stroke();
            ctx.fillText('Sensor B', legendX + 25, legendY + 40);

            ctx.strokeStyle = '#06a77d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + 55);
            ctx.lineTo(legendX + 20, legendY + 55);
            ctx.stroke();
            ctx.fillText('KF Estimate', legendX + 25, legendY + 60);

            // Axes labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Lato';
            ctx.textAlign = 'center';
            ctx.fillText('Time Steps', width / 2, height - 15);

            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Temperature (¬∞C)', 0, 0);
            ctx.restore();
        }

        function useRealData() {
            document.getElementById('trueBulbTemp').value = 250;
            document.getElementById('distA').value = 5;
            document.getElementById('distB').value = 15;
            document.getElementById('noiseA').value = 2.0;
            document.getElementById('noiseB').value = 0.5;
            document.getElementById('processNoise').value = 0.1;
            document.getElementById('numSteps').value = 50;
            
            runSimulation();
        }
    </script>
</head>
<body>
    <header>
        <h1>Indirect Temperature Estimation Using Kalman Filter (Two Sensors)</h1>
        <p class="authors">Tran Hoai Nhan &mdash; Le Hong Nhat Tan</p>
        <p class="course-info">Probability Course Fall 2025 &mdash; Professor: Tran Vinh Linh</p>
        <div class="links">
            <a href="poster_landscape.pdf" target="_blank">üìÑ View Poster (PDF)</a>
            <a href="Temperature_Analysis.xlsx" download>üìä Download Data Analysis</a>
            <a href="https://github.com/leonathn/FinalProjectProbability" target="_blank">üíª GitHub Repository</a>
        </div>
    </header>

    <section>
        <h2>Problem Overview</h2>
        <p>
            In Computational Fluid Dynamics (CFD) simulations of building environments, accurate boundary conditions are critical. 
            Dr. Nguyen Hop Minh's experimental setup requires precise knowledge of a hot bulb's surface temperature (200‚Äì300¬∞C) 
            to validate CFD models. However, direct measurement is impractical‚Äîsensors would melt at such temperatures.
        </p>
        <p>
            We developed an <strong>indirect measurement approach</strong> using two air temperature sensors positioned at different 
            distances from the heat source, combining their readings through a Kalman Filter to estimate the bulb's temperature.
        </p>
    </section>

    <section>
        <h2>Methodology</h2>
        
        <h3>Experimental Setup</h3>
        <div class="figure">
            <img src="SensorPlacement.png" alt="Real experimental setup">
            <p class="figure-caption">Figure 1a: Real experimental setup showing the heat source box with two ambient temperature sensors at different distances.</p>
        </div>

        <div class="figure">
            <img src="SensorPlacementDiagram.png" alt="Sensor placement diagram">
            <p class="figure-caption">Figure 1b: Schematic diagram - Hot bulb (center) radiates heat to Sensor A (close, d<sub>A</sub> = 5 cm) and Sensor B (far, d<sub>B</sub> = 15 cm).</p>
        </div>

        <div class="parameters">
            <p><strong>Sensor A (Close):</strong> Positioned at d<sub>A</sub> = 5 cm from the bulb. Captures near-field temperature with higher signal but more noise (R<sub>A</sub> = 2.0). Experiences stronger thermal fluctuations due to convection effects.</p>
            <p><strong>Sensor B (Far):</strong> Positioned at d<sub>B</sub> = 15 cm from the bulb. Measures far-field temperature with lower signal but higher stability (R<sub>B</sub> = 0.5). Provides reliable baseline measurements.</p>
        </div>

        <h3>Mathematical Framework: Bayesian Inference</h3>
        <p>
            The Kalman Filter implements optimal Bayesian estimation using Gaussian distributions:
        </p>

        <div class="equation">
<strong>Prior Belief:</strong> p(x) = N(x; xÃÇ, P)<br>
where x = T<sub>bulb</sub> is the hidden state (true bulb temperature)
        </div>

        <div class="equation">
<strong>Likelihood:</strong> p(z|x) = N(z; Hx, R)<br>
where z = sensor measurement, H = observation coefficient, R = measurement noise variance
        </div>

        <div class="equation">
<strong>Posterior (Bayes' Rule):</strong> p(x|z) ‚àù p(z|x) ¬∑ p(x)<br>
Results in: p(x|z) = N(x; Œº<sub>post</sub>, œÉ¬≤<sub>post</sub>)
        </div>

        <p>
            The Kalman Filter computes the posterior mean (Œº<sub>post</sub>) and variance (œÉ¬≤<sub>post</sub>) in closed form through two steps:
        </p>

        <h3>Heat Diffusion Model</h3>
        <p>
            We model heat diffusion from the bulb as the hidden state x representing the true bulb temperature. 
            The observed air temperatures at each sensor depend on distance through an inverse relationship:
        </p>
        <div class="equation">
z<sub>A</sub> = H<sub>A</sub> √ó x + v<sub>A</sub>,  where H<sub>A</sub> = d<sub>B</sub>/(d<sub>A</sub> + d<sub>B</sub>) = 15/20 = 0.75<br>
z<sub>B</sub> = H<sub>B</sub> √ó x + v<sub>B</sub>,  where H<sub>B</sub> = d<sub>A</sub>/(d<sub>A</sub> + d<sub>B</sub>) = 5/20 = 0.25
        </div>
        <p>
            where v<sub>A</sub> ~ N(0, R<sub>A</sub>) and v<sub>B</sub> ~ N(0, R<sub>B</sub>) represent Gaussian measurement noise.
        </p>

        <h3>Kalman Filter Algorithm</h3>
        
        <h4>Prediction Step (Prior Propagation)</h4>
        <div class="equation">
xÃÇ<sub>pred</sub> = xÃÇ<sub>prev</sub>  (propagate mean - assuming constant temperature)<br>
P<sub>pred</sub> = P<sub>prev</sub> + Q  (increase uncertainty with process noise)
        </div>
        <p>
            This gives the prior distribution p(x) = N(x; xÃÇ<sub>pred</sub>, P<sub>pred</sub>) before incorporating new measurements.
        </p>

        <h4>Update Step (Posterior via Bayes)</h4>
        <p><strong>Sequential Fusion with Sensor A:</strong></p>
        <div class="equation">
K<sub>A</sub> = P<sub>pred</sub>/(P<sub>pred</sub> + R<sub>A</sub>)  <em>(Bayes weight - Kalman Gain)</em><br>
xÃÇ<sub>A</sub> = xÃÇ<sub>pred</sub> + K<sub>A</sub>(z<sub>A</sub> - H<sub>A</sub>xÃÇ<sub>pred</sub>)  <em>(posterior mean)</em><br>
P<sub>A</sub> = (1 - K<sub>A</sub>H<sub>A</sub>)P<sub>pred</sub>  <em>(posterior variance)</em>
        </div>

        <p><strong>Sequential Fusion with Sensor B:</strong></p>
        <div class="equation">
K<sub>B</sub> = P<sub>A</sub>/(P<sub>A</sub> + R<sub>B</sub>)  <em>(Bayes weight)</em><br>
xÃÇ<sub>new</sub> = xÃÇ<sub>A</sub> + K<sub>B</sub>(z<sub>B</sub> - H<sub>B</sub>xÃÇ<sub>A</sub>)  <em>(final posterior mean)</em><br>
P<sub>new</sub> = (1 - K<sub>B</sub>H<sub>B</sub>)P<sub>A</sub>  <em>(final posterior variance)</em>
        </div>

        <p>
            <strong>Key Insight:</strong> The Kalman Gain K acts as the Bayesian weight, automatically balancing sensor contributions based on relative uncertainties. 
            When Sensor A is noisy (large R<sub>A</sub>), K<sub>A</sub> decreases, giving more weight to the prior. 
            The filter optimally combines both sensors' information to minimize estimation error.
        </p>
    </section>

    <section>
        <h2>Experimental Results</h2>
        
        <div class="figure">
            <img src="experimental_results.png" alt="Experimental results graph">
            <p class="figure-caption">Figure 2: Real experimental data over 600 seconds showing Sensor A (orange), Sensor B (blue), and Kalman Filter estimate (green).</p>
        </div>

        <h3>Data Statistics</h3>
        <div class="statistics">
            <div class="stat-box">
                <h4>Sensor A (Close)</h4>
                <p class="value">36.4 ¬± 2.1¬∞C</p>
            </div>
            <div class="stat-box">
                <h4>Sensor B (Far)</h4>
                <p class="value">30.5 ¬± 0.6¬∞C</p>
            </div>
            <div class="stat-box">
                <h4>Bulb Estimate</h4>
                <p class="value">67.2 ¬± 2.2¬∞C</p>
            </div>
        </div>

        <h3>Key Observations</h3>
        <ul>
            <li>Sensor A exhibits higher variance due to proximity to heat source and convection effects</li>
            <li>Sensor B provides more stable baseline measurements</li>
            <li>The Kalman Filter estimate smoothly tracks the bulb temperature while rejecting sensor noise</li>
            <li>At t=100s: z<sub>A</sub>=40.5¬∞C, z<sub>B</sub>=31.5¬∞C, KF estimate=69.0¬∞C</li>
        </ul>
    </section>

    <section>
        <h2>Understanding Sensor Noise Impact</h2>
        
        <h3>What Does High Noise Mean?</h3>
        <p>
            The noise parameters R<sub>A</sub> and R<sub>B</sub> represent the <strong>variance</strong> of the measurement error. 
            High noise means the sensor readings have large random fluctuations around the true value.
        </p>

        <div class="parameters">
            <h4>üî¥ High Noise Scenario (R<sub>A</sub> = 10.0, R<sub>B</sub> = 8.0)</h4>
            <p><strong>What Happens:</strong></p>
            <ul>
                <li><strong>Kalman Gain Decreases:</strong> K = P/(P + R) ‚Üí When R is large, K becomes very small (close to 0)</li>
                <li><strong>Filter Trusts Sensors Less:</strong> The filter gives more weight to its prediction than to noisy measurements</li>
                <li><strong>Slower Convergence:</strong> It takes more time steps for the estimate to reach the true value</li>
                <li><strong>Smoother but Delayed:</strong> The output is very smooth but may lag behind actual temperature changes</li>
            </ul>
            <p><strong>Mathematical Impact:</strong> With high R, the Kalman Gain K ‚âà 0, so the update equation becomes:</p>
            <div class="equation">
xÃÇ<sub>new</sub> ‚âà xÃÇ<sub>pred</sub> + 0 √ó (z - HxÃÇ<sub>pred</sub>) ‚âà xÃÇ<sub>pred</sub>
            </div>
            <p>This means the filter <em>ignores</em> the measurements and just uses its prediction!</p>
        </div>

        <div class="parameters">
            <h4>üü¢ Low Noise Scenario (R<sub>A</sub> = 0.1, R<sub>B</sub> = 0.05)</h4>
            <p><strong>What Happens:</strong></p>
            <ul>
                <li><strong>Kalman Gain Increases:</strong> K = P/(P + R) ‚Üí When R is small, K approaches 1</li>
                <li><strong>Filter Trusts Sensors More:</strong> The filter heavily weights the actual measurements</li>
                <li><strong>Fast Convergence:</strong> Estimate quickly adjusts to match sensor readings</li>
                <li><strong>More Responsive:</strong> Tracks changes rapidly but may show slight fluctuations</li>
            </ul>
            <p><strong>Mathematical Impact:</strong> With low R, the Kalman Gain K ‚âà 1, so:</p>
            <div class="equation">
xÃÇ<sub>new</sub> ‚âà xÃÇ<sub>pred</sub> + 1 √ó (z - HxÃÇ<sub>pred</sub>) ‚âà z
            </div>
            <p>The filter <em>directly uses</em> the measurements!</p>
        </div>

        <div class="parameters">
            <h4>‚öñÔ∏è Balanced Noise (Our Setup: R<sub>A</sub> = 2.0, R<sub>B</sub> = 0.5)</h4>
            <p><strong>Optimal Trade-off:</strong></p>
            <ul>
                <li><strong>Sensor A:</strong> Higher noise (R<sub>A</sub> = 2.0) ‚Üí Lower weight ‚Üí K<sub>A</sub> smaller</li>
                <li><strong>Sensor B:</strong> Lower noise (R<sub>B</sub> = 0.5) ‚Üí Higher weight ‚Üí K<sub>B</sub> larger</li>
                <li><strong>Complementary Fusion:</strong> Filter automatically gives more trust to the stable Sensor B</li>
                <li><strong>Best of Both:</strong> Combines Sensor A's proximity advantage with Sensor B's stability</li>
            </ul>
            <p><strong>Key Insight:</strong> The Kalman Filter is <em>self-tuning</em> ‚Äî it automatically adjusts how much to trust each sensor based on their noise levels!</p>
        </div>

        <h3>Why This Matters for Our Application</h3>
        <p>
            In the building environment experiment:
        </p>
        <ul>
            <li><strong>Physical Reality:</strong> Sensor A (close to bulb) experiences more turbulence and thermal convection ‚Üí higher R<sub>A</sub></li>
            <li><strong>Stability Trade-off:</strong> Sensor B (far from bulb) is more stable but has weaker signal ‚Üí lower R<sub>B</sub></li>
            <li><strong>Optimal Estimation:</strong> Kalman Filter weighs both sensors according to their reliability, achieving better accuracy than either sensor alone</li>
            <li><strong>Uncertainty Quantification:</strong> The variance P tells us how confident the estimate is ‚Äî crucial for CFD model validation</li>
        </ul>
    </section>

    <section>
        <h2>Interactive Simulation Tool</h2>
        <p>
            Try the Kalman Filter with your own parameters or simulate custom sensor data:
        </p>
        
        <div class="simulator-container">
            <div class="simulator-controls">
                <h3>Configure Parameters</h3>
                
                <div class="param-group">
                    <label for="trueBulbTemp">True Bulb Temperature (¬∞C):</label>
                    <input type="number" id="trueBulbTemp" value="250" min="100" max="400" step="10">
                </div>
                
                <div class="param-group">
                    <label for="distA">Sensor A Distance (cm):</label>
                    <input type="number" id="distA" value="5" min="1" max="20" step="1">
                </div>
                
                <div class="param-group">
                    <label for="distB">Sensor B Distance (cm):</label>
                    <input type="number" id="distB" value="15" min="5" max="50" step="1">
                </div>
                
                <div class="param-group">
                    <label for="noiseA">Sensor A Noise (R<sub>A</sub>):</label>
                    <input type="number" id="noiseA" value="2.0" min="0.1" max="10" step="0.1">
                </div>
                
                <div class="param-group">
                    <label for="noiseB">Sensor B Noise (R<sub>B</sub>):</label>
                    <input type="number" id="noiseB" value="0.5" min="0.1" max="10" step="0.1">
                </div>
                
                <div class="param-group">
                    <label for="processNoise">Process Noise (Q):</label>
                    <input type="number" id="processNoise" value="0.1" min="0" max="2" step="0.1">
                </div>
                
                <div class="param-group">
                    <label for="numSteps">Number of Time Steps:</label>
                    <input type="number" id="numSteps" value="50" min="10" max="200" step="10">
                </div>
                
                <button class="sim-button" onclick="runSimulation()">Run Simulation</button>
                <button class="sim-button secondary" onclick="useRealData()">Use Our Experimental Data</button>
            </div>
            
            <div class="simulator-output">
                <canvas id="simCanvas" width="600" height="400"></canvas>
                <div id="simStats" class="sim-stats"></div>
            </div>
        </div>
    </section>

    <section>
        <h2>Discussion</h2>
        <p>
            This project demonstrates three key concepts:
        </p>
        <ul>
            <li><strong>Indirect Measurement:</strong> When direct observation is impossible, we can infer hidden states from related observable quantities using domain knowledge (heat diffusion physics).</li>
            <li><strong>Sensor Fusion:</strong> Multiple imperfect sensors provide complementary information. The Kalman Filter optimally combines them, outperforming any single sensor.</li>
            <li><strong>Probabilistic Approach:</strong> By modeling uncertainty explicitly (measurement noise, process noise), we obtain not just point estimates but confidence intervals for decision-making.</li>
        </ul>
        <p>
            Future work could incorporate thermal dynamics modeling (heat capacity, cooling rates) and extend to multi-sensor arrays for spatial temperature field reconstruction.
        </p>
    </section>

    <section>
        <h2>References</h2>
        <div class="reference">
            [1] Kalman, R. E. (1960). "A New Approach to Linear Filtering and Prediction Problems." <em>Transactions of the ASME‚ÄìJournal of Basic Engineering</em>, 82(Series D): 35-45.
        </div>
        <div class="reference">
            [2] Welch, G., &amp; Bishop, G. (2006). "An Introduction to the Kalman Filter." <em>University of North Carolina at Chapel Hill</em>, Department of Computer Science, TR 95-041.
        </div>
        <div class="reference">
            [3] Simon, D. (2006). <em>Optimal State Estimation: Kalman, H‚àû, and Nonlinear Approaches</em>. Wiley-Interscience.
        </div>
    </section>

    <footer>
        <p>&copy; 2025 Tran Hoai Nhan &amp; Le Hong Nhat Tan | Probability Course Fall 2025</p>
        <p>Interactive Demo: <a href="https://leonathn.github.io/FinalProjectProbability/" style="color: #1a365d;">https://leonathn.github.io/FinalProjectProbability/</a></p>
    </footer>
</body>
</html>
